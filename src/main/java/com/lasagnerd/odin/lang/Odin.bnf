{
  parserImports="static com.intellij.lang.parser.GeneratedParserUtilBase.*"
  parserClass="com.lasagnerd.odin.lang.OdinParser"

  extends="com.lasagnerd.odin.lang.psi.OdinPsiElement"


  psiClassPrefix="Odin"
  psiImplClassSuffix="Impl"

  psiPackage="com.lasagnerd.odin.lang.psi"
  psiImplPackage="com.lasagnerd.odin.lang.psi.impl"

  elementTypeHolderClass="com.lasagnerd.odin.lang.psi.OdinTypes"
  elementTypeClass="com.lasagnerd.odin.lang.psi.OdinElementType"
  tokenTypeClass="com.lasagnerd.odin.lang.psi.OdinTokenType"
  parserUtilClass="com.lasagnerd.odin.lang.OdinParserUtil"

  tokens=[
        LINE_COMMENT='regexp://[^\r\n]*'
        BLOCK_COMMENT='regexp:/\*[\s\S]*?\*/'

        PACKAGE='regexp:package'
        IMPORT='regexp:import'
        PROC='regexp:proc'
        RETURN='regexp:return'
        DEFER='regexp:defer'
        STRUCT='regexp:struct'
        FOR='regexp:for'
        IN='regexp:in'
        NOT_IN='regexp:not_in'
        DO='regexp:do'
        IF_TOKEN='regexp:if'
        ELSE_TOKEN='regexp:else'
        SWITCH='regexp:switch'
        CASE='regexp:case'
        FALLTHROUGH='regexp:fallthrough'
        WHEN='regexp:when'
        BREAK='regexp:break'
        CONTINUE='regexp:continue'
        TRIPLE_DASH='regexp:---'
        ELLIPSIS='regexp:\.\.\.'
        OR_ELSE='regexp:or_else'
        OR_RETURN='regexp:or_return'
        OR_BREAK='regexp:or_break'
        OR_CONTINUE='regexp:or_continue'
        FOREIGN='regexp:foreign'
        CAST='regexp:cast'
        AUTO_CAST='regexp:AUTO_CAST'
        TRANSMUTE='regexp:TRANSMUTE'
        DYNAMIC='regexp:dynamic'
        BIT_SET='regexp:bit_set'
        MAP='regexp:map'
        USING='regexp:using'
        ENUM='regexp:enum'
        UNION='regexp:union'
        DISTINCT='regexp:distinct'
        WHERE='regexp:where'

        IDENTIFIER_TOKEN='regexp:[a-zA-Z_][a-zA-Z0-9_]*'
        DQ_STRING_LITERAL='regexp:"[^"]*"'
        SQ_STRING_LITERAL="regexp:'[^']+?'"
        RAW_STRING_LITERAL='regexp:`[^`]*`'
        INTEGER_DEC_LITERAL='regexp:[0-9][0-9_]*'
        INTEGER_HEX_LITERAL='regexp:0x[0-9a-fA-F][0-9a-fA-F_]*'
        INTEGER_OCT_LITERAL='regexp:0o[0-7][0-7_]*'
        INTEGER_BIN_LITERAL='regexp:0b[01][01_]*'
        COMPLEX_INTEGER_DEC_LITERAL='regexp:'
        QUAT_INTEGER_DEC_LITERAL='regexp:'

        FLOAT_DEC_LITERAL='regexp:[0-9][0-9_]*\.[0-9][0-9_]*'
        COMPLEX_FLOAT_LITERAL='regexp:'
        QUAT_FLOAT_LITERAL='regexp:'


        EQ='regexp:='
        COLON='regexp::'

        LBRACE='regexp:\{'
        RBRACE='regexp:}'
        LPAREN='regexp:\('
        RPAREN='regexp:\)'

        LBRACKET='regexp:\['
        RBRACKET='regexp:]'
        HASH='regexp:#'

        DOT='regexp:\.'
        ARROW='regexp:->'
        COMMA='regexp:,'
        SEMICOLON='regexp:;'
        QUESTION='regexp:\?'
        CARET='regexp:\^'
        AT='regexp:@'
        DOLLAR='regexp:\$'
        DOT_QUESTION='regexp:\.\?'

        // Operators
        EQEQ='regexp:=='
        NEQ='regexp:!='
        LT='regexp:<'
        GT='regexp:>'
        LTE='regexp:<='
        GTE='regexp:>='

        // Boolean operators
        ANDAND='regexp:&&'
        OROR='regexp:\|\|'
        NOT='regexp:!'
        ANDNOT='regexp:&~'


        // Arithmetic operators
        PLUS='regexp:\+'
        MINUS='regexp:-'
        STAR='regexp:\*'
        DIV='regexp:/'
        MOD='regexp:%'
        REMAINDER='regexp:%%'

        // Bitwise operators
        AND='regexp:&'
        PIPE='regexp:\|'
        TILDE='regexp:~'
        LSHIFT='regexp:<<'
        RSHIFT='regexp:>>'


        // Assignment operators
        PLUS_EQ='regexp:\+='
        MINUS_EQ='regexp:-='
        STAR_EQ='regexp:\*='
        DIV_EQ='regexp:/='
        MOD_EQ='regexp:%='
        REMAINDER_EQ='regexp:%%='
        AND_EQ='regexp:&='
        OR_EQ='regexp:\|='
        XOR_EQ='regexp:~='
        ANDAND_EQ='regexp:&&='
        OROR_EQ='regexp:\|\|='
        LSHIFT_EQ='regexp:<<='
        RSHIFT_EQ='regexp:>>='
        BITWISE_AND_NOT_EQ='regexp:&~='

        // Range Operators
        RANGE = 'regexp:\.\.'
        RANGE_INCLUSIVE='regexp:\.\.='
        RANGE_EXCLUSIVE='regexp:\.\.<'

        WHITE_SPACE='regexp:[ \t\f]+'
        NEW_LINE='regexp:(\r|\n|\r\n)+'
        EOS_TOKEN='EOS_TOKEN'

        MULTILINE_BLOCK_COMMENT='MULTILINE_BLOCK_COMMENT'

        BLOCK_COMMENT_CONTENT='BLOCK_COMMENT_CONTENT'
        BLOCK_COMMENT_START='BLOCK_COMMENT_START'
        BLOCK_COMMENT_END='BLOCK_COMMENT_END'

        DQ_STRING_START='DQ_STRING_START'
        DQ_STRING_END='DQ_STRING_END'

        SQ_STRING_START='SQ_STRING_START'
        SQ_STRING_END='SQ_STRING_END'
  ]

  extends('.*Expression$') = expression
  extends('.*[sS]tatement$') = statement
  extends('.*Type$') = type

  methods('.*([iI]nitialization|[dD]eclaration).*') = [getDeclaredIdentifiers]
  implements('.*([iI]nitialization|[dD]eclaration).*') = 'com.lasagnerd.odin.lang.psi.OdinDeclaration'
  implements('(procedure|struct|union)DeclarationStatement') = 'com.lasagnerd.odin.lang.psi.OdinConstantDeclaration'
  implements('usingStatement') = 'com.lasagnerd.odin.lang.psi.OdinDeclaration'
  methods('usingStatement') = [getDeclaredIdentifiers]
  implements('constantInitializationStatement') = 'com.lasagnerd.odin.lang.psi.OdinConstantDeclaration'
  psiImplUtilClass="com.lasagnerd.odin.lang.psi.OdinPsiUtil"
}

odinFile                             ::= fileScope

// General recovery rules
private eos_recover ::= !eos

fileScope                            ::= packageDeclaration eos importStatementsContainer fileScopeStatementList <<eof>> {
    methods=[getImportStatements getScope]
    mixin= "com.lasagnerd.odin.lang.psi.OdinFileScopeMixin"
    implements=["com.lasagnerd.odin.lang.psi.OdinScopeBlock" "com.lasagnerd.odin.lang.psi.OdinScopeArea"]
}
importStatementsContainer            ::= (importDeclarationStatement eos)*
fileScopeStatementList               ::= (fileScopeStatement eos)*
packageDeclaration                   ::= PACKAGE declaredIdentifier {pin=0 recoverWhile=eos_recover}


importDeclarationStatement           ::= IMPORT declaredIdentifier? DQ_STRING_LITERAL {methods=[alias="/declaredIdentifier" path="/DQ_STRING_LITERAL" getName setName getNameIdentifier getImportInfo] implements="com.intellij.psi.PsiNameIdentifierOwner"}
doubleColonOperator                  ::= COLON COLON

fileScopeStatement                   ::= foreignImportDeclarationStatement
                                         | importDeclarationStatement
                                         | enumDeclarationStatement
                                         | unionDeclarationStatement
                                         | structDeclarationStatement
                                         | procedureDeclarationStatement
                                         | bitsetDeclarationStatement
                                         | constantInitializationStatement
                                         | variableInitializationStatement
                                         | variableDeclarationStatement
                                         | procedureOverloadDeclarationStatement
                                         | foreignStatement
                                         | whenStatement
                                         | directiveStatement

// @require foreign import entry "entryUnixNoCrtAmd64.asm"
foreignImportDeclarationStatement    ::= (attributeStatement EOS_TOKEN?)* FOREIGN IMPORT
        ( (declaredIdentifier? DQ_STRING_LITERAL) | (declaredIdentifier? blockStart DQ_STRING_LITERAL (COMMA DQ_STRING_LITERAL)* COMMA? blockEnd)) {methods=[alias="declaredIdentifier" paths="DQ_STRING_LITERAL"]}

foreignStatement                     ::= (attributeStatement EOS_TOKEN?)* FOREIGN IDENTIFIER_TOKEN? foreignBlock

foreignBlock                         ::= blockStart foreignStatementList? blockEnd

foreignStatementList                 ::= (sos? foreignBlockStatement eos)+
foreignBlockStatement                ::= variableDeclarationStatement
                                         |procedureDeclarationStatement
                                         |whenStatement

// Attributes
attributeStatement                   ::= AT IDENTIFIER_TOKEN
                                         | AT arguments
// Struct
structDeclarationStatement           ::= (attributeStatement eos?)* declaredIdentifier doubleColonOperator DISTINCT? structType
structType                           ::= STRUCT [LPAREN polymorphicParameterList RPAREN [eos? whereClause eos?]] <<enterNoBlockMode>> directive* <<exitNoBlockMode>> structBlock {methods=[getParamEntryList] implements="com.lasagnerd.odin.lang.psi.OdinScopeArea"}
structBlock                          ::= blockStart [structBody] blockEnd
structBody                           ::= fieldDeclarationStatement (COMMA fieldDeclarationStatement)*  [COMMA|EOS_TOKEN] {implements="com.lasagnerd.odin.lang.psi.OdinScopeArea"}
fieldDeclarationStatement            ::= USING? directiveHead? declaredIdentifier (COMMA declaredIdentifier)* COLON type [RAW_STRING_LITERAL] { methods=[ getTypeDefinition ]  }

// Enum
enumDeclarationStatement             ::= (attributeStatement eos?)* USING? declaredIdentifier doubleColonOperator DISTINCT? enumType
enumType                             ::= ENUM [qualifiedType|simpleRefType] enumBlock
enumBlock                            ::= blockStart [enumBody] blockEnd
enumBody                             ::= enumValueDeclaration (COMMA enumValueDeclaration)* [EOS_TOKEN|COMMA]
enumValueDeclaration                 ::= declaredIdentifier [EQ expression]

// Union
unionDeclarationStatement            ::= (attributeStatement eos?)* declaredIdentifier doubleColonOperator DISTINCT? unionType
unionType                            ::= UNION [LPAREN polymorphicParameterList RPAREN [eos? whereClause eos?]] <<enterNoBlockMode>> directive* <<exitNoBlockMode>> unionBlock {methods=[getParamEntryList] implements="com.lasagnerd.odin.lang.psi.OdinScopeArea"}
unionBlock                           ::= blockStart [unionBody] blockEnd
unionBody                            ::= type (COMMA type)* [COMMA|EOS_TOKEN] {implements="com.lasagnerd.odin.lang.psi.OdinScopeArea"}

// Bit Set
bitsetDeclarationStatement           ::= (attributeStatement eos?)* declaredIdentifier doubleColonOperator DISTINCT? bitSetType

// Procedure
procedureDeclarationStatement        ::= (attributeStatement eos?)* declaredIdentifier doubleColonOperator procedureDefinition {implements="com.lasagnerd.odin.lang.psi.OdinScopeBlock" methods = [ getBlockStatements getSymbols ]}
procedureDefinition                  ::= procedureType procedureBody {implements="com.lasagnerd.odin.lang.psi.OdinScopeArea"}
procedureType                        ::= directive? PROC stringLiteral? LPAREN [paramEntries] RPAREN [ARROW returnParameters] <<enterNoBlockMode>> [eos? whereClause eos?] <<exitNoBlockMode>> {methods=[getParamEntryList]}

whereClause                          ::= WHERE expression (COMMA expression)*
procedureBody                        ::= tripleDashBlock
                                          | block
private tripleDashBlock              ::= [directive] TRIPLE_DASH {pin=2}
returnParameters                     ::= NOT | LPAREN paramEntries RPAREN | type {methods=[getParamEntryList]}

returnStatement                      ::= [directive] RETURN returnArgumentList?
private returnArgumentList           ::= expression (COMMA expression)* COMMA?

usingStatement                       ::= USING expression
directiveStatement                   ::= directive

// Procedure overloading
procedureOverloadDeclarationStatement ::= (attributeStatement eos?)* declaredIdentifier doubleColonOperator PROC LBRACE identifier (COMMA identifier)* COMMA? RBRACE

// TYPES

// Variables and constants
typeDefinitionExpression             ::= DISTINCT? [directive] type
type                                 ::= mapType
                                         | matrixType
                                         | bitSetType
                                         | multiPointerType
                                         | sliceType
                                         | arrayType
                                         | relativeType
                                         | procedureType
                                         | structType
                                         | enumType
                                         | unionType
                                         | pointerType
                                         | polymorphicType
                                         | constrainedType
                                         | parExpressionType
                                         | qualifiedType
                                         | callType
                                         | ellipsisType
                                         | variadicType
                                         | simpleRefType

relativeType                         ::= directive type
ellipsisType                         ::= ELLIPSIS
variadicType                         ::= RANGE type
callType                             ::= identifier arguments
constrainedType                      ::= type DIV type {pin=2}
polymorphicType                      ::= DOLLAR declaredIdentifier {implements="com.lasagnerd.odin.lang.psi.OdinDeclaration" methods=[getDeclaredIdentifiers]}
simpleRefType                        ::= identifier
qualifiedType                        ::= identifier DOT (callType | simpleRefType) {methods=[getPackageIdentifier getTypeIdentifier]}


pointerType                          ::= CARET type
multiPointerType                     ::= LBRACKET CARET RBRACKET type


bitSetType                           ::= BIT_SET LBRACKET expression [SEMICOLON type] RBRACKET
mapType                              ::= MAP LBRACKET type RBRACKET type {methods=[getKeyType getValueType]}
matrixType                           ::= MATRIX LBRACKET expression COMMA expression RBRACKET type
arrayType                            ::= [directiveHead] LBRACKET arraySize RBRACKET type {methods=[getTypeDefinition]}
arraySize                            ::= QUESTION|DYNAMIC|expression
sliceType                            ::= [directiveHead] LBRACKET RBRACKET type
constantInitializationStatement      ::= symbolDefinitionHead colonClosing expressionsList { methods=[getTypeDefinition]}
colonClosing                         ::= COLON

private symbolDefinitionHead         ::= (attributeStatement eos?)* [directiveHead] [USING] identifierList colonOpening type?
colonOpening                         ::= COLON

variableInitializationStatement      ::= symbolDefinitionHead EQ expressionsList { methods=[getTypeDefinition]}

identifierList                       ::= declaredIdentifier (COMMA declaredIdentifier)*
declaredIdentifier                   ::= [DOLLAR] IDENTIFIER_TOKEN { mixin = 'com.lasagnerd.odin.lang.psi.OdinIdentifierOwner' implements='com.intellij.psi.PsiNameIdentifierOwner' }

assignmentStatement                  ::= [directiveHead] expressionsList assignmentOperator expressionsList
expressionsList                      ::= expression (COMMA expression)*

assignmentOperator                   ::= EQ
                                         | PLUS_EQ
                                         | MINUS_EQ
                                         | STAR_EQ
                                         | DIV_EQ
                                         | MOD_EQ
                                         | REMAINDER_EQ
                                         | AND_EQ
                                         | OR_EQ
                                         | XOR_EQ
                                         | ANDAND_EQ
                                         | OROR_EQ
                                         | LSHIFT_EQ
                                         | RSHIFT_EQ
                                         | BITWISE_AND_NOT_EQ

variableDeclarationStatement         ::= (attributeStatement eos?)* [USING] identifierList COLON type { methods=[getTypeDefinition]}

// Parameters for procedures and assignments
private polymorphicParameterList     ::= paramEntries

paramEntries                         ::= paramEntry (COMMA paramEntry)* COMMA? {implements="com.lasagnerd.odin.lang.psi.OdinScopeArea"}
paramEntry                           ::= directive? (
                                             parameterInitialization
                                             | parameterDeclarator
                                             | unnamedParameter
                                         )
fake parameterDeclaration            ::= parameter+ typeDefinitionContainer? expression { methods=[getTypeDefinition]}
typeDefinitionContainer              ::= type

parameter                            ::= [USING] directive? declaredIdentifier
parameterDeclarator                  ::= parameter (COMMA parameter)* COLON typeDefinitionContainer {extends=parameterDeclaration  methods=[getTypeDefinition]}
parameterInitialization              ::= parameter COLON [typeDefinitionContainer] EQ expression {extends=parameterDeclaration methods=[getTypeDefinition] }

unnamedParameter                     ::= RANGE? typeDefinitionContainer {extends=parameterDeclaration methods=[getTypeDefinition]}

// Function calls
private argumentList                 ::= argument (COMMA argument)* COMMA?
namedArgument                        ::= IDENTIFIER_TOKEN EQ expression { extends = argument}
argument                             ::= namedArgument
                                         | unnamedArgument
unnamedArgument                      ::= expression { extends = argument}


// Does it make sense to have literal expressions in the chain?

// All expressions
expression                           ::= postfixGroup
                                         | orElseExpression
                                         | ternaryGroup
                                         | rangeGroup
                                         | orGroup
                                         | andGroup
                                         | orderGroup
                                         | addGroup
                                         | mulGroup
                                         | unaryGroup
                                         | implicitSelectorExpression
                                         | maybeExpression
                                         | uninitializedExpression
                                         | callExpression
                                         | qualificationExpression
                                         | indexExpression
                                         | sliceExpression
                                         | dereferenceExpression
                                         | procedureExpression
                                         | transmuteExpression
                                         | autoCastExpression
                                         | castExpression
                                         | compoundLiteralExpression
                                         | primaryGroup



fake binaryExpression                ::= expression 'OP' expression {methods=[left="/expression[0]" getOperator right="/expression[1]"]}

// Arithmetic
mulExpression                        ::= expression STAR            <<enterMode "OPERAND">>  expression <<exitMode "OPERAND" >>   { extends=binaryExpression}
divExpression                        ::= expression DIV             <<enterMode "OPERAND">>  expression <<exitMode "OPERAND" >>   { extends=binaryExpression}
modExpression                        ::= expression MOD             <<enterMode "OPERAND">>  expression <<exitMode "OPERAND" >>   { extends=binaryExpression}
remainderExpression                  ::= expression REMAINDER       <<enterMode "OPERAND">>  expression <<exitMode "OPERAND" >>   { extends=binaryExpression}
addExpression                        ::= expression PLUS            <<enterMode "OPERAND">>  expression <<exitMode "OPERAND" >>   { extends=binaryExpression}
subExpression                        ::= expression MINUS           <<enterMode "OPERAND">>  expression <<exitMode "OPERAND" >>   { extends=binaryExpression}

// Bitwise
bitwiseAndExpression                 ::= expression AND             <<enterMode "OPERAND">>  expression <<exitMode "OPERAND" >>   { extends=binaryExpression}
bitwiseOrExpression                  ::= expression PIPE            <<enterMode "OPERAND">>  expression <<exitMode "OPERAND" >>   { extends=binaryExpression}
bitwiseXorExpression                 ::= expression TILDE           <<enterMode "OPERAND">>  expression <<exitMode "OPERAND" >>   { extends=binaryExpression}
bitwiseAndNotExpression              ::= expression ANDNOT          <<enterMode "OPERAND">>  expression <<exitMode "OPERAND" >>   { extends=binaryExpression}
lshiftExpression                     ::= expression LSHIFT          <<enterMode "OPERAND">>  expression <<exitMode "OPERAND" >>   { extends=binaryExpression}
rshiftExpression                     ::= expression RSHIFT          <<enterMode "OPERAND">>  expression <<exitMode "OPERAND" >>   { extends=binaryExpression}

// or_else
orElseExpression                     ::= expression OR_ELSE         <<enterMode "OPERAND">>  expression <<exitMode "OPERAND" >>   { extends=binaryExpression                             }

// Range
rangeInclusiveExpression             ::= expression RANGE_INCLUSIVE <<enterMode "OPERAND">>  expression <<exitMode "OPERAND" >>   { extends=binaryExpression}
rangeExclusiveExpression             ::= expression RANGE_EXCLUSIVE <<enterMode "OPERAND">>  expression <<exitMode "OPERAND" >>   { extends=binaryExpression}

// boolean operators
inExpression                         ::= expression IN              <<enterMode "OPERAND">>  expression <<exitMode "OPERAND" >>   { extends=binaryExpression}
notInExpression                      ::= expression NOT_IN          <<enterMode "OPERAND">>  expression <<exitMode "OPERAND" >>   { extends=binaryExpression}
ltExpression                         ::= expression LT              <<enterMode "OPERAND">>  expression <<exitMode "OPERAND" >>   { extends=binaryExpression}
gtExpression                         ::= expression GT              <<enterMode "OPERAND">>  expression <<exitMode "OPERAND" >>   { extends=binaryExpression}
lteExpression                        ::= expression LTE             <<enterMode "OPERAND">>  expression <<exitMode "OPERAND" >>   { extends=binaryExpression}
gteExpression                        ::= expression GTE             <<enterMode "OPERAND">>  expression <<exitMode "OPERAND" >>   { extends=binaryExpression}
eqeqExpression                       ::= expression EQEQ            <<enterMode "OPERAND">>  expression <<exitMode "OPERAND" >>   { extends=binaryExpression}
neqExpression                        ::= expression NEQ             <<enterMode "OPERAND">>  expression <<exitMode "OPERAND" >>   { extends=binaryExpression}
orExpression                         ::= expression OROR            <<enterMode "OPERAND">>  expression <<exitMode "OPERAND" >>   { extends=binaryExpression}
andExpression                        ::= expression ANDAND          <<enterMode "OPERAND">>  expression <<exitMode "OPERAND" >>   { extends=binaryExpression}

private mulGroup                     ::= mulExpression
                                         | divExpression
                                         | modExpression
                                         | remainderExpression
                                         | bitwiseAndExpression
                                         | lshiftExpression
                                         | rshiftExpression
                                         | bitwiseAndNotExpression

private addGroup                     ::= addExpression
                                         | subExpression
                                         | bitwiseOrExpression
                                         | bitwiseXorExpression
                                         | inExpression
                                         | notInExpression

private orderGroup                   ::= ltExpression
                                         | gtExpression
                                         | lteExpression
                                         | gteExpression
                                         | eqeqExpression
                                         | neqExpression

private andGroup                     ::= andExpression

private orGroup                      ::= orExpression

private rangeGroup                   ::= rangeInclusiveExpression
                                         | rangeExclusiveExpression

private ternaryGroup                 ::= elvisExpression
                                         | ternaryIfExpression
                                         | ternaryWhenExpression

private postfixGroup                 ::= orReturnExpression
                                         | orBreakExpression
                                         | orContinueExpression


parenthesizedExpression              ::= LPAREN <<enterMode "PAR">> expression <<exitMode "PAR">> RPAREN

// should we define the arrow operator on its own?
fake refExpression                   ::= expression? refOperator (identifier|typeAssert)
simpleRefExpression                  ::= identifier {extends=refExpression elementType=refExpression}
qualificationExpression              ::= expression refOperator (identifier|typeAssert) {extends=refExpression elementType=refExpression pin(".*")=refOperator recoverWhile=eos_recover}
private typeAssert                   ::= LPAREN type RPAREN
private refOperator ::= (DOT|ARROW)


implicitSelectorExpression           ::= DOT identifier
indexExpression                      ::= expression index
sliceExpression                      ::= expression slice
procedureExpression                  ::= procedureTypeContainer procedureBody {implements=["com.lasagnerd.odin.lang.psi.OdinScopeBlock" "com.lasagnerd.odin.lang.psi.OdinScopeArea"] methods = [ getBlockStatements getSymbols ] }
procedureTypeContainer               ::= procedureType
dereferenceExpression                ::= expression CARET
identifier                           ::= IDENTIFIER_TOKEN { methods = [getReference delete]}

callExpression                       ::= expression arguments

private primaryGroup                 ::= simpleRefExpression | parenthesizedExpression | typeDefinitionExpression | directiveExpression | literalExpression

literalExpression                    ::= basicLiteral

compoundLiteralExpression            ::= compoundLiteralTyped | compoundLiteralUntyped
fake compoundValue                   ::= {methods=[getCompoundValueBody]}
fake compoundLiteral                 ::= type? (compoundValueTyped | compoundValueUntyped)
compoundLiteralTyped                 ::= compoundType compoundValueTyped {extends=compoundLiteral}
compoundLiteralUntyped               ::= compoundValueUntyped {extends=compoundLiteral}

index                                ::= LBRACKET expression [COMMA expression] RBRACKET
slice                                ::= LBRACKET expression? COLON expression? RBRACKET
private arguments                    ::= LPAREN <<enterMode "PAR">> argumentList? <<exitMode "PAR">> EOS_TOKEN? RPAREN

elvisExpression                      ::= expression QUESTION <<enterMode "OPERAND">> expression COLON expression <<exitMode "OPERAND">>
ternaryIfExpression                  ::= expression if       <<enterMode "OPERAND">> expression else expression  <<exitMode "OPERAND">>
ternaryWhenExpression                ::= expression WHEN     <<enterMode "OPERAND">> expression else expression  <<exitMode "OPERAND">>

castExpression                       ::= CAST LPAREN type RPAREN expression
transmuteExpression                  ::= TRANSMUTE LPAREN type RPAREN expression
autoCastExpression                   ::= AUTO_CAST expression

uninitializedExpression              ::= TRIPLE_DASH


// TODO this is a duplicate of compoundLiteralValue but without the non-consuming <<>>-rules
// --> fix this
compoundValueUntyped                 ::= ((<<isModeOn "OPERAND">> | <<isModeOn "PAR">> | <<isModeOff "NO_BLOCK">>) compoundValueStart [compoundValueBody] compoundValueEnd)
                                         | (compoundValueStart [compoundValueBody] compoundValueEnd <<beforeOperator>>) {extends=compoundValue elementType=compoundValue}
maybeExpression                      ::= expression DOT_QUESTION

private unaryGroup                   ::= unaryPlusExpression
                                         | unaryMinusExpression
                                         | unaryTildeExpression
                                         | addressExpression
                                         | unaryNotExpression
                                         | unaryRangeExpression



unaryPlusExpression                  ::= PLUS  <<enterMode "OPERAND">> expression <<exitMode "OPERAND">>
unaryMinusExpression                 ::= MINUS <<enterMode "OPERAND">> expression <<exitMode "OPERAND">>
unaryTildeExpression                 ::= TILDE <<enterMode "OPERAND">> expression <<exitMode "OPERAND">>
addressExpression                    ::= AND   <<enterMode "OPERAND">> expression <<exitMode "OPERAND">>
unaryNotExpression                   ::= NOT   <<enterMode "OPERAND">> expression <<exitMode "OPERAND">>
unaryRangeExpression                 ::= RANGE <<enterMode "OPERAND">> expression <<exitMode "OPERAND">>


orReturnExpression                   ::= expression OR_RETURN
orBreakExpression                    ::= expression OR_BREAK [IDENTIFIER_TOKEN]
orContinueExpression                 ::= expression OR_CONTINUE [IDENTIFIER_TOKEN]


stringLiteral                        ::= DQ_STRING_LITERAL
                                         | SQ_STRING_LITERAL
                                         | RAW_STRING_LITERAL  {extends=basicLiteral}

numericLiteral                       ::= INTEGER_DEC_LITERAL
                                         | INTEGER_HEX_LITERAL
                                         | INTEGER_OCT_LITERAL
                                         | INTEGER_BIN_LITERAL
                                         | FLOAT_DEC_LITERAL
                                         | COMPLEX_INTEGER_DEC_LITERAL
                                         | QUAT_INTEGER_DEC_LITERAL
                                         | COMPLEX_FLOAT_LITERAL
                                         | QUAT_FLOAT_LITERAL  {extends=basicLiteral}
// TODO there is no such thing as a boolean literal in Odin, true and false are just
//  identifiers that have the type bool and the respective values. Things as
//  true :: false are allowed

basicLiteral                         ::= stringLiteral
                                         | numericLiteral

private compoundType                 ::= sliceType | arrayType | matrixType | bitSetType  | mapType | structType | qualifiedType | callType | simpleRefType | parExpressionType
parExpressionType                    ::= parenthesizedExpression


compoundValueTyped                   ::= ((<<isModeOn "PAR">> | <<isModeOff "NO_BLOCK">>) compoundValueStart [compoundValueBody] compoundValueEnd)
                                         | (compoundValueStart [compoundValueBody] compoundValueEnd <<beforeComma>>) {extends=compoundValue elementType=compoundValue}
compoundValueStart                   ::= LBRACE
compoundValueEnd                     ::= RBRACE
compoundValueBody                    ::= [expression EQ] expression (COMMA [expression EQ] expression)* [EOS_TOKEN|COMMA]

directiveExpression                  ::= directive
directive                            ::= directiveHead [basicLiteral | (LPAREN expressionsList? RPAREN)]
directiveHead                        ::= HASH IDENTIFIER_TOKEN



breakStatement                       ::= BREAK IDENTIFIER_TOKEN?
continueStatement                    ::= CONTINUE IDENTIFIER_TOKEN?

// Represents a code block
block                                ::= [eos] directive* [eos] blockStart statementList? blockEnd {methods=[getStatements]}
blockStart                           ::= LBRACE
blockEnd                             ::= RBRACE


eos                                  ::= SEMICOLON | <<eof>> | EOS_TOKEN | <<multilineBlockComment>> | <<atClosingBrace>> | <<afterClosingBrace>>
sos                                  ::= SEMICOLON | NEW_LINE | EOS_TOKEN | <<afterClosingBrace>> | <<multilineBlockComment>>
statementList                        ::= (sos? statement eos)+ {implements=["com.lasagnerd.odin.lang.psi.OdinScopeArea"]}
statement                            ::= assignmentStatement
                                         | procedureDeclarationStatement
                                         | variableInitializationStatement
                                         | structDeclarationStatement
                                         | enumDeclarationStatement
                                         | unionDeclarationStatement
                                         | procedureOverloadDeclarationStatement
                                         | constantInitializationStatement
                                         | variableDeclarationStatement
                                         | bitsetDeclarationStatement
                                         | blockStatement
                                         | forInStatement
                                         | forStatement
                                         | conditionalStatement
                                         | whenStatement
                                         | switchStatement
                                         | deferStatement
                                         | returnStatement
                                         | breakStatement
                                         | continueStatement
                                         | usingStatement
                                         | expressionStatement
                                         | fallthroughStatement
                                         | foreignImportDeclarationStatement
                                         | foreignStatement
                                         | importDeclarationStatement
                                         | semicolonStatement

semicolonStatement                   ::= SEMICOLON
fallthroughStatement                 ::= FALLTHROUGH
expressionStatement                  ::= orReturnExpression
                                          | orBreakExpression
                                          | orContinueExpression
                                          | callExpression
                                          | qualificationExpression
                                          | typeAssert
                                          | primaryGroup

labelDeclaration                     ::= declaredIdentifier COLON
blockStatement                       ::= [directive eos?] [labelDeclaration] block {implements=["com.lasagnerd.odin.lang.psi.OdinScopeBlock" "com.lasagnerd.odin.lang.psi.OdinScopeArea"] methods = [ getBlockStatements getSymbols ] }

deferStatement                       ::= DEFER deferrableStatement
private deferrableStatement          ::= assignmentStatement
                                         | expression
                                         | conditionalStatement
                                         | forStatement
                                         | switchStatement
                                         | block

// Control Flows

// Shared rules among all control flow statements
controlFlowInit                  ::= assignmentStatement
                                         | variableInitializationStatement
                                         | variableDeclarationStatement
                                         | callExpression

condition                            ::= expression
doStatement                          ::= DO statement {implements="com.lasagnerd.odin.lang.psi.OdinScopeArea"}
statementBody                        ::= block|doStatement

// For
forStatement                         ::= [directive] [labelDeclaration] forBlock {implements="com.lasagnerd.odin.lang.psi.OdinScopeArea"}
private forHead                      ::= <<enterNoBlockMode>> [[[controlFlowInit] SEMICOLON] condition? [SEMICOLON [forUpdate]]] <<exitNoBlockMode>>
forBlock                             ::= FOR forHead statementBody {implements=["com.lasagnerd.odin.lang.psi.OdinScopeBlock" "com.lasagnerd.odin.lang.psi.OdinScopeArea"] methods = [ getBlockStatements getSymbols ] }
forUpdate                            ::= assignmentStatement | callExpression

// For-InG
forInStatement                       ::= [directive] [labelDeclaration] forInBlock {implements="com.lasagnerd.odin.lang.psi.OdinScopeArea"}
forInBlock                           ::= FOR <<enterNoBlockMode>> [forInParameterDeclaration (COMMA forInParameterDeclaration)*] IN expression <<exitNoBlockMode>> statementBody {implements=["com.lasagnerd.odin.lang.psi.OdinScopeBlock" "com.lasagnerd.odin.lang.psi.OdinScopeArea"] methods = [ getBlockStatements getSymbols ] }
forInParameterDeclaration            ::= AND? declaredIdentifier

// Conditional statement (=if-elseif-else)
private conditionalHead              ::= <<enterNoBlockMode>> [[controlFlowInit] SEMICOLON] condition <<exitNoBlockMode>>

conditionalStatement                 ::= [directive] [labelDeclaration] ifBlock {implements=["com.lasagnerd.odin.lang.psi.OdinScopeArea"]}

ifBlock                              ::= if conditionalHead statementBody [sos elseBlock] {
                                                implements=["com.lasagnerd.odin.lang.psi.OdinScopeBlock" "com.lasagnerd.odin.lang.psi.OdinScopeArea"]
                                                methods = [ getBlockStatements getSymbols ]
                                         }
elseBlock                            ::= else (ifBlock|statementBody) {implements=["com.lasagnerd.odin.lang.psi.OdinScopeBlock" "com.lasagnerd.odin.lang.psi.OdinScopeArea"] methods = [ getBlockStatements getSymbols ] }
if                                   ::= IF_TOKEN
else                                 ::= ELSE_TOKEN

// Switch
switchStatement                      ::= [directive] [labelDeclaration] (switchInBlock|switchBlock) {implements=["com.lasagnerd.odin.lang.psi.OdinScopeArea"]}

switchInBlock                        ::= SWITCH switchTypeVariableDeclaration IN expression switchBody {implements="com.lasagnerd.odin.lang.psi.OdinScopeArea"}
switchTypeVariableDeclaration        ::= declaredIdentifier
switchBlock                          ::= SWITCH switchHead switchBody {implements="com.lasagnerd.odin.lang.psi.OdinScopeArea"}
private switchHead                   ::= <<enterNoBlockMode>> [[controlFlowInit SEMICOLON] [expression]] <<exitNoBlockMode>>
switchBody                           ::= eos? blockStart switchCases blockEnd
switchCases                          ::= switchCase*
switchCase                           ::= CASE [expression (COMMA expression)*] caseBlock
caseBlock                            ::= COLON statementList?

// When statement (compile time, which means it does not support an init block)
whenStatement                        ::= [directive] [labelDeclaration] whenBlock
whenBlock                            ::= WHEN <<enterNoBlockMode>> condition <<exitNoBlockMode>> statementBody [sos elseWhenBlock]
elseWhenBlock                        ::= else (whenBlock|statementBody)



