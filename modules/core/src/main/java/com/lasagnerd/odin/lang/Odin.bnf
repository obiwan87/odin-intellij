{
  parserClass="com.lasagnerd.odin.lang.OdinParser"

  extends="com.lasagnerd.odin.lang.psi.impl.OdinPsiElementImpl"
  implements="com.lasagnerd.odin.lang.psi.OdinPsiElement"

  psiClassPrefix="Odin"
  psiImplClassSuffix="Impl"

  psiPackage="com.lasagnerd.odin.lang.psi"
  psiImplPackage="com.lasagnerd.odin.lang.psi.impl"

  elementTypeHolderClass="com.lasagnerd.odin.lang.psi.OdinTypes"
  elementTypeClass="com.lasagnerd.odin.lang.psi.OdinElementType"
  tokenTypeClass="com.lasagnerd.odin.lang.psi.OdinTokenType"
  parserUtilClass="com.lasagnerd.odin.lang.OdinParserUtil"

  tokens=[
        LINE_COMMENT='regexp://[^\r\n]*'
        BLOCK_COMMENT='regexp:/\*[\s\S]*?\*/'

        PACKAGE='regexp:package'
        IMPORT='regexp:import'
        PROC='regexp:proc'
        RETURN='regexp:return'
        DEFER='regexp:defer'
        STRUCT='regexp:struct'
        FOR='regexp:for'
        IN='regexp:in'
        NOT_IN='regexp:not_in'
        DO='regexp:do'
        IF_TOKEN='regexp:if'
        ELSE_TOKEN='regexp:else'
        SWITCH='regexp:switch'
        CASE='regexp:case'
        FALLTHROUGH='regexp:fallthrough'
        WHEN='regexp:when'
        BREAK='regexp:break'
        CONTINUE='regexp:continue'
        TRIPLE_DASH='regexp:---'
        ELLIPSIS='regexp:\.\.\.'
        OR_ELSE='regexp:or_else'
        OR_RETURN='regexp:or_return'
        OR_BREAK='regexp:or_break'
        OR_CONTINUE='regexp:or_continue'
        FOREIGN='regexp:foreign'
        CAST='regexp:cast'
        AUTO_CAST='regexp:AUTO_CAST'
        TRANSMUTE='regexp:TRANSMUTE'
        DYNAMIC='regexp:dynamic'
        BIT_SET='regexp:bit_set'
        BIT_FIELD='regexp:bit_set'
        MAP='regexp:map'
        USING='regexp:using'
        ENUM='regexp:enum'
        UNION='regexp:union'
        DISTINCT='regexp:distinct'
        WHERE='regexp:where'

        IDENTIFIER_TOKEN='regexp:[a-zA-Z_][a-zA-Z0-9_]*'
        DQ_STRING_LITERAL='regexp:"[^"]*"'
        SQ_STRING_LITERAL="regexp:'[^']+?'"
        RAW_STRING_LITERAL='regexp:`[^`]*`'
        INTEGER_DEC_LITERAL='regexp:[0-9][0-9_]*'
        INTEGER_HEX_LITERAL='regexp:0x[0-9a-fA-F][0-9a-fA-F_]*'
        INTEGER_OCT_LITERAL='regexp:0o[0-7][0-7_]*'
        INTEGER_BIN_LITERAL='regexp:0b[01][01_]*'
        COMPLEX_INTEGER_DEC_LITERAL='regexp:'
        QUAT_INTEGER_DEC_LITERAL='regexp:'

        FLOAT_DEC_LITERAL='regexp:[0-9][0-9_]*\.[0-9][0-9_]*'
        COMPLEX_FLOAT_LITERAL='regexp:'
        QUAT_FLOAT_LITERAL='regexp:'


        EQ='regexp:='
        COLON='regexp::'

        LBRACE='regexp:\{'
        RBRACE='regexp:}'
        LPAREN='regexp:\('
        RPAREN='regexp:\)'

        LBRACKET='regexp:\['
        RBRACKET='regexp:]'
        HASH='regexp:#'

        DOT='regexp:\.'
        ARROW='regexp:->'
        COMMA='regexp:,'
        SEMICOLON='regexp:;'
        QUESTION='regexp:\?'
        CARET='regexp:\^'
        AT='regexp:@'
        DOLLAR='regexp:\$'
        DOT_QUESTION='regexp:\.\?'

        // Operators
        EQEQ='regexp:=='
        NEQ='regexp:!='
        LT='regexp:<'
        GT='regexp:>'
        LTE='regexp:<='
        GTE='regexp:>='

        // Boolean operators
        ANDAND='regexp:&&'
        OROR='regexp:\|\|'
        NOT='regexp:!'
        ANDNOT='regexp:&~'


        // Arithmetic operators
        PLUS='regexp:\+'
        MINUS='regexp:-'
        STAR='regexp:\*'
        DIV='regexp:/'
        MOD='regexp:%'
        REMAINDER='regexp:%%'

        // Bitwise operators
        AND='regexp:&'
        PIPE='regexp:\|'
        TILDE='regexp:~'
        LSHIFT='regexp:<<'
        RSHIFT='regexp:>>'


        // Assignment operators
        PLUS_EQ='regexp:\+='
        MINUS_EQ='regexp:-='
        STAR_EQ='regexp:\*='
        DIV_EQ='regexp:/='
        MOD_EQ='regexp:%='
        REMAINDER_EQ='regexp:%%='
        AND_EQ='regexp:&='
        OR_EQ='regexp:\|='
        XOR_EQ='regexp:~='
        ANDAND_EQ='regexp:&&='
        OROR_EQ='regexp:\|\|='
        LSHIFT_EQ='regexp:<<='
        RSHIFT_EQ='regexp:>>='
        BITWISE_AND_NOT_EQ='regexp:&~='

        // Range Operators
        RANGE = 'regexp:\.\.'
        RANGE_INCLUSIVE='regexp:\.\.='
        RANGE_EXCLUSIVE='regexp:\.\.<'

        WHITE_SPACE='regexp:[ \t\f]+'
        NEW_LINE='regexp:(\r|\n|\r\n)+'
        EOS_TOKEN='EOS_TOKEN'

        MULTILINE_BLOCK_COMMENT='MULTILINE_BLOCK_COMMENT'

        BLOCK_COMMENT_CONTENT='BLOCK_COMMENT_CONTENT'
        BLOCK_COMMENT_START='BLOCK_COMMENT_START'
        BLOCK_COMMENT_END='BLOCK_COMMENT_END'

        DQ_STRING_START='DQ_STRING_START'
        DQ_STRING_END='DQ_STRING_END'

        SQ_STRING_START='SQ_STRING_START'
        SQ_STRING_END='SQ_STRING_END'
        BUILD_FLAG_PREFIX_TOKEN='regexp:'
        BUILD_FLAG_IDENTIFIER_TOKEN='BUILD_FLAG_IDENTIFIER_TOKEN'
  ]

  extends('.*Expression$') = expression
  extends('.*[sS]tatement$') = statement
  extends('.*Type$') = type

  methods('.*([iI]nitialization|[dD]eclaration)Statement') = [getDeclaration]
  methods('.*([iI]nitialization|[dD]eclaration)$') = [getDeclaredIdentifiers]
  methods('.*[dD]eclaration$') = [getName getPresentation getIcon]

  implements('.*([iI]nitialization|[dD]eclaration)$') = 'com.lasagnerd.odin.lang.psi.OdinDeclaration'

  implements("binaryExpression|unaryExpression|castExpression|transmuteExpression|autoCastExpression|orElseExpression|orReturnExpression|orBreakExpression|orContinueExpression|ternaryExpression") = 'com.lasagnerd.odin.lang.psi.OdinOperation'
  implements('importDeclaration|constantInitDeclaration') = 'com.lasagnerd.odin.lang.psi.OdinConstantDeclaration'
  implements('constantInitDeclaration') = "com.lasagnerd.odin.lang.psi.OdinAttributesOwner"
  implements('usingStatement') = 'com.lasagnerd.odin.lang.psi.OdinDeclaration'
  methods('usingStatement') = [getDeclaredIdentifiers]

  psiImplUtilClass="com.lasagnerd.odin.lang.psi.OdinPsiUtil"

  elementTypeFactory("fileScope|packageClause|importDeclaration|shortVariableDeclaration|initVariableDeclaration|declaredIdentifier|constantInitDeclaration") =  "com.lasagnerd.odin.lang.stubs.OdinStubElementTypeFactory.create"

  extends("packageClause|importDeclaration|shortVariableDeclaration|initVariableDeclaration|constantInitDeclaration") = "com.lasagnerd.odin.lang.psi.impl.OdinStubbedElementImpl<?>"
}

odinFile                             ::= fileScope

// General recover rules
private eos_recover ::= !eos

fileScope                            ::= buildFlagClause* packageClause eos importStatementsContainer? fileScopeStatementList <<eof>> {
    methods=[getImportStatements getSymbolTable getBuildFlagsValuesStore]
    mixin= "com.lasagnerd.odin.lang.psi.impl.OdinFileScopeMixin"
    implements=["com.lasagnerd.odin.lang.psi.OdinScopeBlock"]
    stubClass="com.lasagnerd.odin.lang.stubs.OdinFileScopeStub"
}

buildFlagClause                      ::= buildFlagPrefix [buildFlagArguments]
private buildFlagArguments           ::= buildFlagArgument (COMMA buildFlagArgument)* // disjunction
buildFlagArgument                    ::= buildFlag+ // conjunction
buildFlagPrefix                      ::= BUILD_FLAG_PREFIX_TOKEN
buildFlagIdentifier                  ::= BUILD_FLAG_IDENTIFIER_TOKEN {extends=buildFlag methods=[getBuildFlagIdentifierToken]}
buildFlagNegation                    ::= NOT buildFlag {extends=buildFlag}
buildFlag                            ::= buildFlagIdentifier
                                         | buildFlagNegation
importStatementsContainer            ::= (importStatement eos)+
fileScopeStatementList               ::= (fileScopeStatement (eos|<<afterNewLine>>))*
packageClause                        ::= PACKAGE declaredIdentifier {
    pin=1
    recoverWhile=eos_recover
    stubClass="com.lasagnerd.odin.lang.stubs.OdinPackageClauseStub"
    methods=[getName]
}

importStatement           ::= importDeclaration {implements="com.lasagnerd.odin.lang.psi.OdinDeclarationProvidingStatement<com.lasagnerd.odin.lang.psi.OdinImportDeclaration>" methods=[getDeclaration]}
importDeclaration         ::= [attributesDefinition EOS_TOKEN?] IMPORT declaredIdentifier? importPath {
  methods=[alias="/declaredIdentifier"
  path="/importPath" getName setName getNameIdentifier getImportInfo]
  implements=["com.intellij.psi.PsiNameIdentifierOwner"]
  stubClass="com.lasagnerd.odin.lang.stubs.OdinImportDeclarationStub"
}

importPath                           ::= DQ_STRING_LITERAL {
                                                        methods=[
                                                                getReference
                                                                getReferences
                                                                getImportInfo
                                                                shouldAskParentForReferences
                                                                ] implements=["com.intellij.psi.HintedReferenceHost"]}

fileScopeStatement                   ::= foreignImportDeclarationStatement
                                         | importStatement
                                         | constantInitializationStatement
                                         | initVariableStatement
                                         | shortVariableDeclarationStatement
                                         | foreignStatement
                                         | whenStatement
                                         | directiveStatement

// @require foreign import entry "entryUnixNoCrtAmd64.asm"
foreignImportDeclarationStatement    ::= (attributesDefinition EOS_TOKEN?)* FOREIGN IMPORT declaredIdentifier? (foreignImportPath | foreignImportBlock) {methods=[alias="declaredIdentifier" getName setName getNameIdentifier] implements=["com.intellij.psi.PsiNameIdentifierOwner" "com.lasagnerd.odin.lang.psi.OdinDeclaration"]}
foreignImportPath                    ::= expression
private foreignImportBlock           ::= blockStart foreignImportPath (COMMA foreignImportPath)* COMMA? blockEnd

foreignStatement                     ::= (attributesDefinition EOS_TOKEN?)* FOREIGN identifier? eos? foreignBlock {implements=["com.lasagnerd.odin.lang.psi.OdinConstantDeclaration"]}

foreignBlock                         ::= blockStart foreignStatementList? blockEnd {implements="com.lasagnerd.odin.lang.psi.OdinScopeBlock"}

foreignStatementList                 ::= (sos? foreignBlockStatement eos)+
foreignBlockStatement                ::= shortVariableDeclarationStatement
                                         | constantInitializationStatement
                                         | whenStatement

// Attributes
attributesDefinition                  ::= AT unassignedAttribute
                                         | AT LPAREN <<enterMode "PAR">> attributeList? <<exitMode "PAR">> EOS_TOKEN? RPAREN

attributeIdentifier ::= IDENTIFIER_TOKEN

private attributeList               ::= attributeArgument (COMMA attributeArgument)* COMMA?
assignedAttribute                   ::= attributeIdentifier EQ attributeNamedValue { extends = attributeArgument}
attributeNamedValue                 ::= expression { implements='com.intellij.psi.PsiNameIdentifierOwner' methods=[getName setName getNameIdentifier]}
unassignedAttribute                 ::= attributeIdentifier {extends = attributeArgument}
attributeArgument                   ::= assignedAttribute
                                         | unassignedAttribute {implements="com.lasagnerd.odin.lang.psi.OdinScopeBlock"}

// Struct
structType                           ::= STRUCT [polyParams] <<enterNoBlockMode>> directive* <<exitNoBlockMode>> EOS_TOKEN? structBlock
                                            { methods=[getParamEntryList]
                                              pin=1
                                              implements="com.lasagnerd.odin.lang.psi.OdinScopeBlock"}
private polyParams                   ::= LPAREN polymorphicParameterList RPAREN [eos? whereClause eos?] {pin=1}


structBlock                          ::= blockStart [structBody] blockEnd
structBody                           ::= fieldDeclaration (COMMA fieldDeclaration)*  (COMMA|EOS_TOKEN|&RBRACE) {implements="com.lasagnerd.odin.lang.psi.OdinScopeBlock"}
fieldDeclaration                     ::= USING? directiveIdentifier? fieldDeclarator [structTag] { methods=[ getTypeDefinition ] pin="declaredIdentifier" }

structTag                            ::= RAW_STRING_LITERAL
private fieldDeclarator              ::= declaredIdentifier (COMMA declaredIdentifier)* COLON type {pin(".*")=1 recoverWhile=fieldRecover}
private fieldRecover                 ::= !(EOS_TOKEN | COMMA  | RBRACE | RAW_STRING_LITERAL)

// Enum
enumType                             ::= ENUM [enumBackingType| LPAREN enumBackingType RPAREN] EOS_TOKEN? enumBlock {pin=1}
private enumBackingType              ::= qualifiedType|simpleRefType
enumBlock                            ::= blockStart [enumBody] blockEnd
enumBody                             ::= enumValueDeclaration (COMMA enumValueDeclaration)* [EOS_TOKEN|COMMA] {implements="com.lasagnerd.odin.lang.psi.OdinScopeBlock"}
enumValueDeclaration                 ::= declaredIdentifier [EQ expression]

// Union
unionType                            ::= UNION [polyParams] <<enterNoBlockMode>> directive* <<exitNoBlockMode>> EOS_TOKEN? unionBlock
                                        {
                                            pin=1
                                            methods=[getParamEntryList]
                                            implements="com.lasagnerd.odin.lang.psi.OdinScopeBlock"
                                        }
unionBlock                           ::= blockStart [unionBody] blockEnd
unionBody                            ::= type (COMMA type)* [COMMA|EOS_TOKEN] {implements="com.lasagnerd.odin.lang.psi.OdinScopeBlock"}


// Bit field
bitFieldType                         ::= BIT_FIELD type EOS_TOKEN? bitFieldBlock {pin=1 implements="com.lasagnerd.odin.lang.psi.OdinScopeBlock"}
bitFieldBlock                        ::= blockStart bitFieldBody? blockEnd
bitFieldBody                         ::= bitFieldFieldDeclaration (COMMA bitFieldFieldDeclaration )*  [COMMA|EOS_TOKEN]
bitFieldFieldDeclaration             ::= declaredIdentifier COLON type PIPE expression

// Procedure

procedureLiteralType                 ::= procedureDefinition
procedureDefinition                  ::= procedureSignature procedureBody {implements="com.lasagnerd.odin.lang.psi.OdinScopeBlock"}
procedureSignature                   ::= procedureType
procedureType                        ::= [directive] !procedureGroupHead PROC stringLiteral? LPAREN [paramEntries] RPAREN [ARROW returnParameters] <<enterNoBlockMode>> [eos? whereClause eos?] <<exitNoBlockMode>>
                                            {pin="PROC" methods=[getParamEntryList]}
whereClause                          ::= WHERE <<enterNoBlockMode>> expressionListWithRecover <<exitNoBlockMode>> {pin=1}
procedureBody                        ::= (tripleDashBlock)
                                          | (block)
private tripleDashBlock              ::= [directive] TRIPLE_DASH {pin=2}
returnParameters                     ::= NOT | LPAREN paramEntries RPAREN | type {methods=[getParamEntryList]}

returnStatement                      ::= [directive] RETURN returnArgumentList?
private returnArgumentList           ::= expression (COMMA expression)* COMMA?

usingStatement                       ::= USING expressionListWithRecover
directiveStatement                   ::= directive

// Procedure overloading
procedureGroupType                 ::= &procedureGroupHead PROC EOS_TOKEN? procedureGroupBlock {pin=2 methods=[getProcedureRefList]}
procedureGroupBlock                ::= blockStart procedureGroupBody blockEnd
procedureGroupBody                 ::= procedureRef (COMMA procedureRef)* (COMMA | EOS_TOKEN | &RBRACE)
private procedureGroupHead         ::= PROC EOS_TOKEN? blockStart
procedureRef                       ::= qualifiedType | simpleRefType

// TYPES

// Variables and constants
typeDefinitionExpression             ::= DISTINCT? [directive] type

//noinspection BnfUnreachableChoiceBranch
type                                 ::= mapType
                                         | matrixType
                                         | bitSetType
                                         | multiPointerType
                                         | sliceType
                                         | dynamicArrayType
                                         | arrayType
                                         | procedureType
                                         | procedureGroupType
                                         | relativeType
                                         | structType
                                         | enumType
                                         | unionType
                                         | bitFieldType
                                         | pointerType
                                         | polymorphicType
                                         | constrainedType
                                         | parExpressionType
                                         | callType
                                         | qualifiedType
                                         | ellipsisType
                                         | variadicType
                                         | simpleRefType
{mixin="com.lasagnerd.odin.lang.psi.impl.OdinTypeMixin" methods=[getResolvedType]}

relativeType                         ::= <<relativeTypeRule relativeDef>> type
private relativeDef                  ::= qualifiedType|simpleRefType
ellipsisType                         ::= ELLIPSIS
variadicType                         ::= RANGE type
callType                             ::= type LPAREN <<enterMode "PAR">> <<enterMode "TYPE_LIST">>  argumentList? <<exitMode "TYPE_LIST">> <<exitMode "PAR">> EOS_TOKEN?  RPAREN
constrainedType                      ::= type DIV type
polymorphicType                      ::= DOLLAR declaredIdentifier {implements="com.lasagnerd.odin.lang.psi.OdinDeclaration" methods=[getDeclaredIdentifiers]}
simpleRefType                        ::= identifier
qualifiedType                        ::= identifier DOT simpleRefType {methods=[getPackageIdentifier getTypeIdentifier]}


pointerType                          ::= CARET type
multiPointerType                     ::= LBRACKET CARET RBRACKET type

bitSetType                           ::= BIT_SET bitSetDef {pin=1}
private bitSetDef ::= LBRACKET expression [SEMICOLON type] RBRACKET

mapType                              ::= MAP mapDef {pin=1 methods=[getKeyType getValueType]}
private mapDef                       ::= LBRACKET type RBRACKET type
matrixType                           ::= MATRIX matrixDef {pin=1}
private matrixDef                    ::= LBRACKET arraySize COMMA arraySize RBRACKET type {pin=1}

arrayType                            ::= [directiveIdentifier] LBRACKET arraySize RBRACKET type {methods=[getTypeDefinition]}
arraySize                            ::= QUESTION|expression

dynamicArrayType                     ::= [directiveIdentifier] LBRACKET DYNAMIC RBRACKET type {methods=[getTypeDefinition]}

sliceType                            ::= [directiveIdentifier] LBRACKET RBRACKET type
constantInitializationStatement      ::= constantInitDeclaration { methods=[getExpressionList] implements="com.lasagnerd.odin.lang.psi.OdinDeclarationProvidingStatement<com.lasagnerd.odin.lang.psi.OdinConstantInitDeclaration>"}
constantInitDeclaration              ::= symbolDefinitionHead colonClosing  <<guardedExpression incompleteGuard expressionListWithRecover>> {
    pin=2
    methods=[getExpressionList getDeclaration]
    stubClass="com.lasagnerd.odin.lang.stubs.OdinConstantInitDeclarationStub"
}

private incompleteGuard              ::= !(<<afterNewLine>> (symbolDefinitionHead|!expression))
colonClosing                         ::= COLON

private symbolDefinitionHead         ::= (attributesDefinition eos?)* [directiveIdentifier] [USING] identifierList colonOpening type?
colonOpening                         ::= COLON

initVariableStatement                ::= initVariableDeclaration {
    implements=["com.lasagnerd.odin.lang.psi.OdinVariableStatement<com.lasagnerd.odin.lang.psi.OdinInitVariableDeclaration>"]
    methods=[getDeclaration getTypeDefinition getRhsExpressions]
}

initVariableDeclaration              ::= symbolDefinitionHead EQ <<guardedExpression incompleteGuard rhsExpressions>> {
    pin=2
    implements="com.lasagnerd.odin.lang.psi.OdinVariableDeclaration"
    methods=[getTypeDefinition getRhsExpressions getDeclaredIdentifiers]
    stubClass="com.lasagnerd.odin.lang.stubs.OdinInitVariableDeclarationStub"
}

shortVariableDeclarationStatement    ::= shortVariableDeclaration { implements=["com.lasagnerd.odin.lang.psi.OdinVariableStatement<com.lasagnerd.odin.lang.psi.OdinShortVariableDeclaration>"] }
shortVariableDeclaration             ::= (attributesDefinition eos?)* [USING] identifierList COLON type {
    stubClass="com.lasagnerd.odin.lang.stubs.OdinShortVariableDeclarationStub"
    implements="com.lasagnerd.odin.lang.psi.OdinVariableDeclaration"
}


private identifierList                       ::= declaredIdentifier (COMMA declaredIdentifier)*
declaredIdentifier                   ::= [DOLLAR] IDENTIFIER_TOKEN {
    mixin = 'com.lasagnerd.odin.lang.psi.OdinDeclaredIdentifierMixin'
    implements=['com.intellij.psi.PsiNameIdentifierOwner' "com.lasagnerd.odin.lang.psi.OdinPsiElement"]
    methods=[getPresentation getType]
    stubClass="com.lasagnerd.odin.lang.stubs.OdinDeclaredIdentifierStub"
}

assignmentStatement                  ::= [directiveIdentifier] lhsExpressions assignmentOperator rhsExpressions
lhsExpressions                       ::= expressionListWithRecover
rhsExpressions                       ::= expressionListWithRecover


private expressionListWithRecover ::= expressionWithRecover (COMMA (expressionWithRecover | eos | &LPAREN))* {pin(".*")=1}
// private expressionList            ::= expression (COMMA expression)*
private expressionWithRecover ::= expression {recoverWhile=expressionRecover}
private expressionRecover ::= !( NOT
                                    | NEQ
                                    | MOD
                                    | MOD_EQ
                                    | ANDAND
                                    | AND
                                    | AND_EQ
                                    | ANDAND_EQ
                                    | ANDNOT
                                    | BITWISE_AND_NOT_EQ
                                    | LPAREN
                                    | RPAREN
                                    | STAR
                                    | STAR_EQ
                                    | PLUS
                                    | PLUS_EQ
                                    | COMMA
                                    | MINUS
                                    | MINUS_EQ
                                    | DIV
                                    | DIV_EQ
                                    | COLON
                                    | SEMICOLON
                                    | LT
                                    | LSHIFT
                                    | LSHIFT_EQ
                                    | LTE
                                    | EOS_TOKEN
                                    | EQ
                                    | EQEQ
                                    | GT
                                    | GTE
                                    | RSHIFT
                                    | RSHIFT_EQ
                                    | LBRACKET
                                    | RBRACKET
                                    | XOR
                                    | XOR_EQ
                                    | LBRACE
                                    | PIPE
                                    | OR_EQ
                                    | OROR_EQ
                                    | OROR
                                    | RBRACE
                                    | BREAK
                                    | CASE
                                    | CONTINUE
                                    | DEFER
                                    | ELSE_TOKEN
                                    | FALLTHROUGH
                                    | FOR
                                    | FOREIGN
                                    | PROC
                                    | IDENTIFIER_TOKEN
                                    | IF_TOKEN
                                    | MAP
                                    | RETURN
                                    | SQ_STRING_LITERAL
                                    | RAW_STRING_LITERAL
                                    | STRUCT
                                    | SWITCH
                                    | TRIPLE_DASH
                                    | directive
                                    )


assignmentOperator                   ::= EQ
                                         | PLUS_EQ
                                         | MINUS_EQ
                                         | STAR_EQ
                                         | DIV_EQ
                                         | MOD_EQ
                                         | REMAINDER_EQ
                                         | AND_EQ
                                         | OR_EQ
                                         | XOR_EQ
                                         | ANDAND_EQ
                                         | OROR_EQ
                                         | LSHIFT_EQ
                                         | RSHIFT_EQ
                                         | BITWISE_AND_NOT_EQ


// Parameters for procedures and assignments
private polymorphicParameterList     ::= paramEntries

paramEntries                         ::= paramEntry (COMMA paramEntry)* COMMA? EOS_TOKEN? {implements="com.lasagnerd.odin.lang.psi.OdinScopeBlock"}
paramEntry                           ::= directive? (
                                             parameterInitialization
                                             | parameterDeclarator
                                             | unnamedParameter
                                         )
fake parameterDeclaration            ::= parameter+ typeDefinitionContainer? expression { methods=[getTypeDefinition]}
typeDefinitionContainer              ::= type

parameter                            ::= [USING] directive? declaredIdentifier
parameterDeclarator                  ::= parameter (COMMA parameter)* COLON typeDefinitionContainer {extends=parameterDeclaration  methods=[getTypeDefinition] pin="COLON"}
parameterInitialization              ::= parameter COLON [typeDefinitionContainer] EQ expression {extends=parameterDeclaration methods=[getTypeDefinition] }

unnamedParameter                     ::= RANGE? typeDefinitionContainer {extends=parameterDeclaration methods=[getTypeDefinition]}

// Function calls
private argumentList                 ::= argument (COMMA argument)* COMMA?
namedArgument                        ::= identifier EQ expression { extends = argument}
argument                             ::= namedArgument
                                         | unnamedArgument {implements="com.lasagnerd.odin.lang.psi.OdinScopeBlock"}
unnamedArgument                      ::= expression { extends = argument}


// Does it make sense to have literal expressions in the chain?

// All expressions
expression                           ::= postfixGroup
                                         | orElseExpression
                                         | ternaryGroup
                                         | rangeGroup
                                         | orGroup
                                         | andGroup
                                         | comparisonGroup
                                         | addGroup
                                         | mulGroup
                                         | unaryGroup
                                         | implicitSelectorExpression
                                         | maybeExpression
                                         | uninitializedExpression
                                         | castExpression
                                         | callExpression
                                         | autoCastExpression
                                         | qualificationExpression
                                         | indexExpression
                                         | sliceExpression
                                         | dereferenceExpression
                                         | compoundLiteralExpression
                                         | primaryGroup

{mixin="com.lasagnerd.odin.lang.psi.impl.OdinExpressionMixin" methods=[getInferredType]}


fake binaryExpression                ::= expression 'OP' expression {methods=[left="/expression[0]" getOperator right="/expression[1]"]}

// Arithmetic
mulExpression                        ::= expression STAR            <<enterMode "OPERAND">>  expression <<exitMode "OPERAND" >>   { extends=binaryExpression}
divExpression                        ::= expression DIV             <<enterMode "OPERAND">>  expression <<exitMode "OPERAND" >>   { extends=binaryExpression}
modExpression                        ::= expression MOD             <<enterMode "OPERAND">>  expression <<exitMode "OPERAND" >>   { extends=binaryExpression}
remainderExpression                  ::= expression REMAINDER       <<enterMode "OPERAND">>  expression <<exitMode "OPERAND" >>   { extends=binaryExpression}
addExpression                        ::= expression PLUS            <<enterMode "OPERAND">>  expression <<exitMode "OPERAND" >>   { extends=binaryExpression}
subExpression                        ::= expression MINUS           <<enterMode "OPERAND">>  expression <<exitMode "OPERAND" >>   { extends=binaryExpression}

// Bitwise
bitwiseAndExpression                 ::= expression AND             <<enterMode "OPERAND">>  expression <<exitMode "OPERAND" >>   { extends=binaryExpression}
bitwiseOrExpression                  ::= expression PIPE            <<enterMode "OPERAND">>  expression <<exitMode "OPERAND" >>   { extends=binaryExpression}
bitwiseXorExpression                 ::= expression TILDE           <<enterMode "OPERAND">>  expression <<exitMode "OPERAND" >>   { extends=binaryExpression}
bitwiseAndNotExpression              ::= expression ANDNOT          <<enterMode "OPERAND">>  expression <<exitMode "OPERAND" >>   { extends=binaryExpression}
lshiftExpression                     ::= expression LSHIFT          <<enterMode "OPERAND">>  expression <<exitMode "OPERAND" >>   { extends=binaryExpression}
rshiftExpression                     ::= expression RSHIFT          <<enterMode "OPERAND">>  expression <<exitMode "OPERAND" >>   { extends=binaryExpression}

// or_else
orElseExpression                     ::= expression OR_ELSE         <<enterMode "OPERAND">>  expression <<exitMode "OPERAND" >>   { extends=binaryExpression}

// Range
rangeInclusiveExpression             ::= expression RANGE_INCLUSIVE <<enterMode "OPERAND">>  expression <<exitMode "OPERAND" >>   { extends=binaryExpression}
rangeExclusiveExpression             ::= expression RANGE_EXCLUSIVE <<enterMode "OPERAND">>  expression <<exitMode "OPERAND" >>   { extends=binaryExpression}

// boolean operators
inExpression                         ::= expression IN              <<enterMode "OPERAND">>  expression <<exitMode "OPERAND" >>   { extends=binaryExpression}
notInExpression                      ::= expression NOT_IN          <<enterMode "OPERAND">>  expression <<exitMode "OPERAND" >>   { extends=binaryExpression}
ltExpression                         ::= expression LT              <<enterMode "OPERAND">>  expression <<exitMode "OPERAND" >>   { extends=binaryExpression}
gtExpression                         ::= expression GT              <<enterMode "OPERAND">>  expression <<exitMode "OPERAND" >>   { extends=binaryExpression}
lteExpression                        ::= expression LTE             <<enterMode "OPERAND">>  expression <<exitMode "OPERAND" >>   { extends=binaryExpression}
gteExpression                        ::= expression GTE             <<enterMode "OPERAND">>  expression <<exitMode "OPERAND" >>   { extends=binaryExpression}
eqeqExpression                       ::= expression EQEQ            <<enterMode "OPERAND">>  expression <<exitMode "OPERAND" >>   { extends=binaryExpression}
neqExpression                        ::= expression NEQ             <<enterMode "OPERAND">>  expression <<exitMode "OPERAND" >>   { extends=binaryExpression}
orExpression                         ::= expression OROR            <<enterMode "OPERAND">>  expression <<exitMode "OPERAND" >>   { extends=binaryExpression}
andExpression                        ::= expression ANDAND          <<enterMode "OPERAND">>  expression <<exitMode "OPERAND" >>   { extends=binaryExpression}

private mulGroup                     ::= mulExpression
                                         | divExpression
                                         | modExpression
                                         | remainderExpression
                                         | bitwiseAndExpression
                                         | lshiftExpression
                                         | rshiftExpression
                                         | bitwiseAndNotExpression

private addGroup                     ::= addExpression
                                         | subExpression
                                         | bitwiseOrExpression
                                         | bitwiseXorExpression
                                         | inExpression
                                         | notInExpression

private comparisonGroup              ::= ltExpression
                                         | gtExpression
                                         | lteExpression
                                         | gteExpression
                                         | eqeqExpression
                                         | neqExpression

private andGroup                     ::= andExpression

private orGroup                      ::= orExpression

private rangeGroup                   ::= rangeInclusiveExpression
                                         | rangeExclusiveExpression

private ternaryGroup                 ::= elvisExpression
                                         | ternaryIfExpression
                                         | ternaryWhenExpression

private postfixGroup                 ::= orReturnExpression
                                         | orBreakExpression
                                         | orContinueExpression


parenthesizedExpression              ::= LPAREN <<enterMode "PAR">> expression <<exitMode "PAR">> EOS_TOKEN? RPAREN

// should we define the arrow operator on its own?
fake refExpression                   ::= expression? refOperator (identifier|typeAssert)
simpleRefExpression                  ::= identifier {extends=refExpression elementType=refExpression}
qualificationExpression              ::= expression refOperator (identifier|typeAssert) {extends=refExpression elementType=refExpression pin(".*")=refOperator recoverWhile=eos_recover}
private typeAssert                   ::= LPAREN type RPAREN
private refOperator ::= (DOT|ARROW)


implicitSelectorExpression           ::= DOT identifier
indexExpression                      ::= expression index
sliceExpression                      ::= expression slice
procedureExpression                  ::= DISTINCT? directive? procedureLiteralType {implements=["com.lasagnerd.odin.lang.psi.OdinScopeBlock"] methods = [  getSymbols ] }
dereferenceExpression                ::= expression CARET
identifier                           ::= IDENTIFIER_TOKEN { methods = [getReference delete] mixin="com.lasagnerd.odin.lang.psi.impl.OdinReferenceOwnerMixin" implements=["OdinReferenceOwner"]}

callExpression                       ::= expression LPAREN <<enterMode "PAR">> argumentList? <<exitMode "PAR">> EOS_TOKEN? RPAREN

private primaryGroup                 ::= simpleRefExpression
                                         | transmuteExpression
                                         | parenthesizedExpression
                                         | procedureExpression
                                         | typeDefinitionExpression
                                         | directiveExpression
                                         | literalExpression


literalExpression                    ::= basicLiteral

compoundLiteralExpression            ::= compoundLiteralTyped | compoundLiteralUntyped
fake compoundValue                   ::= {methods=[getCompoundValueBody]}
fake compoundLiteral                 ::= typeContainer (compoundValueTyped | compoundValueUntyped)

compoundLiteralTyped                 ::= !procedureType typeContainer compoundValueTyped {extends=compoundLiteral implements="com.lasagnerd.odin.lang.psi.OdinScopeBlock"}
typeContainer ::= sliceType
                | dynamicArrayType
                | arrayType
                | matrixType
                | bitSetType
                | mapType
                | structType
                | bitFieldType
                | qualifiedType
                | callType
                | simpleRefType
                | parExpressionType

compoundLiteralUntyped               ::= compoundValueUntyped                   {extends=compoundLiteral implements="com.lasagnerd.odin.lang.psi.OdinScopeBlock"}

index                                ::= LBRACKET expression [COMMA expression] RBRACKET
slice                                ::= LBRACKET expression? COLON expression? RBRACKET

fake ternaryExpression               ::= expression 'OP' expression 'OP' expression
elvisExpression                      ::= expression QUESTION <<enterMode "OPERAND">> expression EOS_TOKEN? COLON expression <<exitMode "OPERAND">> {extends=ternaryExpression}
ternaryIfExpression                  ::= expression IF_TOKEN <<enterMode "OPERAND">> expression EOS_TOKEN? ELSE_TOKEN expression  <<exitMode "OPERAND">> {extends=ternaryExpression}
ternaryWhenExpression                ::= expression WHEN     <<enterMode "OPERAND">> expression EOS_TOKEN? ELSE_TOKEN expression  <<exitMode "OPERAND">> {extends=ternaryExpression}

castExpression                       ::= CAST LPAREN type RPAREN expression
transmuteExpression                  ::= TRANSMUTE LPAREN type RPAREN expression
autoCastExpression                   ::= AUTO_CAST expression

uninitializedExpression              ::= TRIPLE_DASH


// TODO this is a duplicate of compoundLiteralValue but without the non-consuming <<>>-rules
// --> fix this
compoundValueUntyped                 ::= ((<<isModeOn "OPERAND">> | <<isModeOn "PAR">> | <<isModeOff "NO_BLOCK">>) compoundValueStart [compoundValueBody] compoundValueEnd)
                                         | (compoundValueStart [compoundValueBody] compoundValueEnd <<beforeOperator>>) {extends=compoundValue elementType=compoundValue}
maybeExpression                      ::= expression DOT_QUESTION

private unaryGroup                   ::= unaryPlusExpression
                                         | unaryMinusExpression
                                         | unaryTildeExpression
                                         | addressExpression
                                         | unaryNotExpression
                                         | unaryRangeExpression


fake unaryExpression                 ::= 'OP' expression {methods=[getOperator]}

unaryPlusExpression                  ::= PLUS  <<enterMode "OPERAND">> expression <<exitMode "OPERAND">> {extends=unaryExpression}
unaryMinusExpression                 ::= MINUS <<enterMode "OPERAND">> expression <<exitMode "OPERAND">> {extends=unaryExpression}
unaryTildeExpression                 ::= TILDE <<enterMode "OPERAND">> expression <<exitMode "OPERAND">> {extends=unaryExpression}
addressExpression                    ::= AND   <<enterMode "OPERAND">> expression <<exitMode "OPERAND">> {extends=unaryExpression}
unaryNotExpression                   ::= NOT   <<enterMode "OPERAND">> expression <<exitMode "OPERAND">> {extends=unaryExpression}
unaryRangeExpression                 ::= RANGE <<enterMode "OPERAND">> expression <<exitMode "OPERAND">> {extends=unaryExpression}


orReturnExpression                   ::= expression OR_RETURN
orBreakExpression                    ::= expression OR_BREAK [IDENTIFIER_TOKEN]
orContinueExpression                 ::= expression OR_CONTINUE [IDENTIFIER_TOKEN]


stringLiteral                        ::= DQ_STRING_LITERAL
                                         | SQ_STRING_LITERAL
                                         | RAW_STRING_LITERAL  {extends=basicLiteral}

numericLiteral                       ::= INTEGER_DEC_LITERAL
                                         | INTEGER_HEX_LITERAL
                                         | INTEGER_OCT_LITERAL
                                         | INTEGER_BIN_LITERAL
                                         | FLOAT_DEC_LITERAL
                                         | COMPLEX_INTEGER_DEC_LITERAL
                                         | QUAT_INTEGER_DEC_LITERAL
                                         | COMPLEX_FLOAT_LITERAL
                                         | QUAT_FLOAT_LITERAL  {extends=basicLiteral}
// TODO there is no such thing as a boolean literal in Odin, true and false are just
//  identifiers that have the type bool and the respective values. Things as
//  true :: false are allowed

basicLiteral                         ::= stringLiteral
                                         | numericLiteral

parExpressionType                    ::= parenthesizedExpression


compoundValueTyped                   ::= (( <<isModeOn "PAR">> | <<isModeOff "NO_BLOCK">>) compoundValueStart [compoundValueBody] compoundValueEnd) {extends=compoundValue elementType=compoundValue}
compoundValueStart                   ::= LBRACE
compoundValueEnd                     ::= RBRACE
compoundValueBody                    ::= elementEntry (COMMA elementEntry)* (EOS_TOKEN|COMMA|&RBRACE)
elementEntry                         ::= lhs EQ rhs
                                         | rhs {pin(".*")=2 recoverWhile=elemEntryRecover}
private elemEntryRecover             ::= !(COMMA | EOS_TOKEN | RBRACE)
lhs                                  ::= expression
rhs                                  ::= expression

directiveExpression                  ::= directiveIdentifier !(IF_TOKEN|STRUCT|WHEN|UNION|SWITCH|ENUM|PROC|FOR|BIT_SET|BIT_FIELD) // do not match as expression before any type or control flow block
directive                            ::= directiveIdentifier [(LPAREN argumentList? RPAREN)]
directiveIdentifier                  ::= HASH IDENTIFIER_TOKEN



breakStatement                       ::= BREAK IDENTIFIER_TOKEN?
continueStatement                    ::= CONTINUE IDENTIFIER_TOKEN?

// Represents a code block
block                                ::= [eos] directive* [eos] blockStart statementList? blockEnd {methods=[getStatements]}
blockStart                           ::= LBRACE
blockEnd                             ::= RBRACE


eos                                  ::= SEMICOLON | <<eof>> | EOS_TOKEN | <<multilineBlockComment>> | &RBRACE | <<afterClosingBrace>>
sos                                  ::= SEMICOLON | NEW_LINE | EOS_TOKEN | <<afterClosingBrace>> | <<multilineBlockComment>>
statementList                        ::= statementWithSemi+ {implements=["com.lasagnerd.odin.lang.psi.OdinScopeBlock"]}
private statementWithSemi            ::= sos? statement (eos|<<afterNewLine>>) {pin=2 recoverWhile=statementRecover}
private statementRecover             ::= !(NOT
                                         | AND
                                         | LPAREN
                                         | STAR
                                         | PLUS
                                         | MINUS
                                         | SEMICOLON
                                         | CARET
                                         | LBRACE
                                         | OR
                                         | OR_EQ
                                         | OROR
                                         | RBRACE
                                         | BREAK
                                         | CASE
                                         | CONTINUE
                                         | OR_CONTINUE
                                         | OR_BREAK
                                         | OR_ELSE
                                         | OR_RETURN
                                         | USING
                                         | DEFER
                                         | ELSE_TOKEN
                                         | FALLTHROUGH
                                         | FOR
                                         | PROC
                                         | IDENTIFIER_TOKEN
                                         | IF_TOKEN
                                         | WHEN
                                         | MAP
                                         | directive
                                         | FOREIGN
                                         | TRIPLE_DASH
                                         | AT
                                         | RETURN
                                         | STRUCT
                                         | SWITCH)
statement                            ::= assignmentStatement
                                         | forStatement
                                         | constantInitializationStatement
                                         | initVariableStatement
                                         | shortVariableDeclarationStatement
                                         | blockStatement
                                         | ifStatement
                                         | whenStatement
                                         | switchStatement
                                         | deferStatement
                                         | returnStatement
                                         | breakStatement
                                         | continueStatement
                                         | usingStatement
                                         | expressionStatement
                                         | fallthroughStatement
                                         | foreignImportDeclarationStatement
                                         | foreignStatement
                                         | importStatement
                                         | semicolonStatement

semicolonStatement                   ::= SEMICOLON
fallthroughStatement                 ::= FALLTHROUGH
expressionStatement                  ::= orReturnExpression
                                          | orBreakExpression
                                          | orContinueExpression
                                          | callExpression
                                          | qualificationExpression
                                          | typeAssert
                                          | primaryGroup

labelDeclaration                     ::= declaredIdentifier COLON
blockStatement                       ::= [directive eos?] [labelDeclaration] block {implements=["com.lasagnerd.odin.lang.psi.OdinScopeBlock"] methods = [  getSymbols ] }

deferStatement                       ::= DEFER deferrableStatement
private deferrableStatement          ::= assignmentStatement
                                         | forStatement
                                         | switchStatement
                                         | ifStatement
                                         | block
                                         | expression

// Control Flows

// Shared rules among all control flow statements
controlFlowInit                  ::= assignmentStatement
                                         | initVariableStatement
                                         | shortVariableDeclarationStatement
                                         | callExpression

condition                            ::= expression
doStatement                          ::= DO statement {implements="com.lasagnerd.odin.lang.psi.OdinScopeBlock"}
statementBody                        ::= block|doStatement

// For
forStatement                         ::= [labelDeclaration] [directive] forBlock {implements="com.lasagnerd.odin.lang.psi.OdinScopeBlock"}
//private forHead                      ::= <<enterNoBlockMode>> [[[controlFlowInit] SEMICOLON] condition? [SEMICOLON [forUpdate]]] <<exitNoBlockMode>>
//forBlock                             ::= FOR forHead statementBody {implements=["com.lasagnerd.odin.lang.psi.OdinScopeBlock"] methods = [  getSymbols ] }
forUpdate                            ::= assignmentStatement | callExpression

forBlock                             ::= FOR <<enterNoBlockMode>> [forOrInClause | expression] <<exitNoBlockMode>> statementBody
                                                    {
                                                        pin(".*")="FOR|forOrInClause"
                                                        recoverWhile=forRecover
                                                        implements=["com.lasagnerd.odin.lang.psi.OdinScopeBlock"]
                                                        methods = [  getSymbols ]
                                                    }
private forRecover                  ::= !(eos | FOR)
forInParameterDeclaration            ::= [forInParameterDeclarator (COMMA forInParameterDeclarator)*] IN expression
forInParameterDeclarator             ::= AND? declaredIdentifier

private forOrInClause                ::= (forClause | forInParameterDeclaration)
private forClause                            ::= controlFlowInit? SEMICOLON expression? SEMICOLON forUpdate?

// Conditional statement (=if-elseif-else)
private conditionalHead              ::= <<enterNoBlockMode>> [[controlFlowInit] SEMICOLON] condition <<exitNoBlockMode>>

ifStatement                          ::= [directive] [labelDeclaration] ifBlock {implements=["com.lasagnerd.odin.lang.psi.OdinScopeBlock"]}

ifBlock                              ::= if conditionalHead eos? statementBody [sos elseBlock] {
                                                pin=".*"
                                                recoverWhile=ifRecover
                                                implements=["com.lasagnerd.odin.lang.psi.OdinScopeBlock"]
                                                methods = [  getSymbols ]
                                         }
private ifRecover                   ::= !(eos | IF_TOKEN)
elseBlock                            ::= else (statementBody|ifBlock) {pin=1 implements=["com.lasagnerd.odin.lang.psi.OdinScopeBlock"] methods = [  getSymbols ] }
if                                   ::= IF_TOKEN
else                                 ::= ELSE_TOKEN

// Switch
switchStatement                      ::= [directive] [labelDeclaration] switchBlock {implements=["com.lasagnerd.odin.lang.psi.OdinScopeBlock"]}

switchTypeVariableDeclaration        ::= AND? declaredIdentifier
switchInClause                       ::= switchTypeVariableDeclaration IN switchInExpressionScope {methods=[getExpression]}
switchInExpressionScope              ::= expression {implements="com.lasagnerd.odin.lang.psi.OdinScopeBlock"}
switchBlock                          ::= SWITCH [switchInClause | switchHead] switchBody {implements="com.lasagnerd.odin.lang.psi.OdinScopeBlock" pin=1 recoverWhile=switchRecover}
private switchRecover                       ::= !(eos | SWITCH)
private switchHead                   ::= <<enterNoBlockMode>> [[controlFlowInit SEMICOLON] [expression]] <<exitNoBlockMode>>
switchBody                           ::= eos? blockStart [switchCases] blockEnd
switchCases                          ::= switchCase+
switchCase                           ::= CASE [caseClause] caseClauseColon caseBlock  {pin=1 recoverWhile=caseRecover}
caseClauseColon ::= COLON
caseClause                           ::= expression (COMMA expression)*
private caseRecover                  ::= !(EOS_TOKEN !RBRACE
                                           | COLON
                                           | CASE
                                           | RBRACE)
caseBlock                            ::= [<<beforeColon>> statementList]

// When statement (compile time, which means it does not support an init block)
whenStatement                        ::= [directive] [labelDeclaration] whenBlock {implements="com.lasagnerd.odin.lang.psi.OdinConstantDeclaration"}
whenBlock                            ::= WHEN <<enterNoBlockMode>> condition <<exitNoBlockMode>> statementBody [sos elseWhenBlock]
    {pin=1 }
elseWhenBlock                        ::= else (whenBlock|statementBody) {pin=1}